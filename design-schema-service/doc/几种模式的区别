装饰器：原来的方法（编码）已经不能满足新需求了，需要对其进行扩展（设计、测试），理论上我们可以对原方法无限地装饰下去，
比如我们可以在"设计"之前再加个"需求分析"，在"测试"之后再加个"部署实施"等等。也可以去掉某些装饰器。

适配器：原来的接口已经不兼容了，适配器在原对象和目标对象中间，通过对原对象兼容的那个接口，通过转换，调用目标对象那个不兼容的接口。
举个不恰当的例子，一个英国人去买饭，听不懂中国服务员说什么（接口不兼容），这时候来了一个翻译（适配器），
他能与英国人交流（接口适配成功），然后翻译不干活，而是通过中国服务员的活动，将结果再返回给英国人。

代理：你们要实现什么功能我不管，我只负责调用该调用的方法。有点类似前台MM，你们干什么我不管，你就告诉我你找谁，我给你找去。

模板方法：如果说装饰器是在原有的方法上扩展很多方法，那么模板方法模式就是将原来很多固定的方法抽出到父类里。一个是加法，一个是减法。


装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，
代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。
并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

我们可以用另外一句话来总结这些差别：使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。